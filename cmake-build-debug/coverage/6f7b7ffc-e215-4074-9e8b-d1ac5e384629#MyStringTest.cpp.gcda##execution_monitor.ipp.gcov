        -:    0:Source:F:/Files/vcpkg/installed/x86-windows/include/boost/test/impl/execution_monitor.ipp
        -:    0:Graph:F:\SoftwareProjects\CLionProjects\C++\My_String\cmake-build-debug\test\CMakeFiles\Boost_Tests_run.dir\MyStringTest.cpp.gcno
        -:    0:Data:F:\SoftwareProjects\CLionProjects\C++\My_String\cmake-build-debug\test\CMakeFiles\Boost_Tests_run.dir\MyStringTest.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://  (C) Copyright Gennadiy Rozental 2001.
        -:    2://  (C) Copyright Beman Dawes and Ullrich Koethe 1995-2001.
        -:    3://  Use, modification, and distribution are subject to the
        -:    4://  Boost Software License, Version 1.0. (See accompanying file
        -:    5://  http://www.boost.org/LICENSE_1_0.txt)
        -:    6:
        -:    7://  See http://www.boost.org/libs/test for the library home page.
        -:    8://
        -:    9:///  @file
        -:   10:///  Provides execution monitor implementation for all supported
        -:   11:///  configurations, including Microsoft structured exception based, unix signals
        -:   12:///  based and special workarounds for borland
        -:   13:///
        -:   14:///  Note that when testing requirements or user wishes preclude use of this
        -:   15:///  file as a separate compilation unit, it may be included as a header file.
        -:   16:///
        -:   17:///  Header dependencies are deliberately restricted to reduce coupling to other
        -:   18:///  boost libraries.
        -:   19:// ***************************************************************************
        -:   20:
        -:   21:#ifndef BOOST_TEST_EXECUTION_MONITOR_IPP_012205GER
        -:   22:#define BOOST_TEST_EXECUTION_MONITOR_IPP_012205GER
        -:   23:
        -:   24:// Boost.Test
        -:   25:#include <boost/test/detail/config.hpp>
        -:   26:#include <boost/test/detail/throw_exception.hpp>
        -:   27:#include <boost/test/execution_monitor.hpp>
        -:   28:#include <boost/test/debug.hpp>
        -:   29:
        -:   30:// Boost
        -:   31:#include <boost/cstdlib.hpp>    // for exit codes
        -:   32:#include <boost/config.hpp>     // for workarounds
        -:   33:#include <boost/core/ignore_unused.hpp> // for ignore_unused
        -:   34:#ifndef BOOST_NO_EXCEPTIONS
        -:   35:#include <boost/exception/get_error_info.hpp> // for get_error_info
        -:   36:#include <boost/exception/current_exception_cast.hpp> // for current_exception_cast
        -:   37:#include <boost/exception/diagnostic_information.hpp>
        -:   38:#endif
        -:   39:
        -:   40:// STL
        -:   41:#include <string>               // for std::string
        -:   42:#include <new>                  // for std::bad_alloc
        -:   43:#include <typeinfo>             // for std::bad_cast, std::bad_typeid
        -:   44:#include <exception>            // for std::exception, std::bad_exception
        -:   45:#include <stdexcept>            // for std exception hierarchy
        -:   46:#include <cstring>              // for C string API
        -:   47:#include <cassert>              // for assert
        -:   48:#include <cstddef>              // for NULL
        -:   49:#include <cstdio>               // for vsnprintf
        -:   50:#include <stdio.h>
        -:   51:#include <cstdarg>              // for varargs
        -:   52:#include <stdarg.h>
        -:   53:#include <cmath>                // for ceil
        -:   54:
        -:   55:#include <iostream>              // for varargs
        -:   56:
        -:   57:#ifdef BOOST_NO_STDC_NAMESPACE
        -:   58:namespace std { using ::strerror; using ::strlen; using ::strncat; using ::ceil; }
        -:   59:#endif
        -:   60:
        -:   61:// to use vsnprintf
        -:   62:#if defined(__SUNPRO_CC) || defined(__SunOS) || defined(__QNXNTO__) || defined(__VXWORKS__)
        -:   63:using std::va_list;
        -:   64:#endif
        -:   65:
        -:   66:#if defined(__VXWORKS__)
        -:   67:# define BOOST_TEST_LIMITED_SIGNAL_DETAILS
        -:   68:#endif
        -:   69:
        -:   70:#ifdef BOOST_SEH_BASED_SIGNAL_HANDLING
        -:   71:
        -:   72:# if !defined(_WIN32_WINNT) // WinXP
        -:   73:#   define _WIN32_WINNT  0x0501
        -:   74:# endif
        -:   75:
        -:   76:#  include <windows.h>
        -:   77:
        -:   78:#  if defined(__MWERKS__) || (defined(_MSC_VER) && !defined(UNDER_CE))
        -:   79:#    include <eh.h>
        -:   80:#  endif
        -:   81:
        -:   82:#  if defined(__BORLANDC__) && __BORLANDC__ >= 0x560 || defined(__MWERKS__)
        -:   83:#    include <stdint.h>
        -:   84:#  endif
        -:   85:
        -:   86:#  if defined(__BORLANDC__) && __BORLANDC__ < 0x560
        -:   87:    typedef unsigned uintptr_t;
        -:   88:#  endif
        -:   89:
        -:   90:#  if defined(UNDER_CE) && BOOST_WORKAROUND(_MSC_VER,  < 1500 )
        -:   91:   typedef void* uintptr_t;
        -:   92:#  elif defined(UNDER_CE)
        -:   93:#  include <crtdefs.h>
        -:   94:#  endif
        -:   95:
        -:   96:#  if !defined(NDEBUG) && defined(_MSC_VER) && !defined(UNDER_CE)
        -:   97:#    include <crtdbg.h>
        -:   98:#    define BOOST_TEST_CRT_HOOK_TYPE    _CRT_REPORT_HOOK
        -:   99:#    define BOOST_TEST_CRT_ASSERT       _CRT_ASSERT
        -:  100:#    define BOOST_TEST_CRT_ERROR        _CRT_ERROR
        -:  101:#    define BOOST_TEST_CRT_SET_HOOK(H)  _CrtSetReportHook(H)
        -:  102:#  else
        -:  103:#    define BOOST_TEST_CRT_HOOK_TYPE    void*
        -:  104:#    define BOOST_TEST_CRT_ASSERT       2
        -:  105:#    define BOOST_TEST_CRT_ERROR        1
        -:  106:#    define BOOST_TEST_CRT_SET_HOOK(H)  (void*)(H)
        -:  107:#  endif
        -:  108:
        -:  109:#  if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501) /* WinXP */
        -:  110:#    define BOOST_TEST_WIN32_WAITABLE_TIMERS
        -:  111:#  endif
        -:  112:
        -:  113:#  if (!BOOST_WORKAROUND(_MSC_VER,  >= 1400 ) && \
        -:  114:      !defined(BOOST_COMO)) || defined(UNDER_CE)
        -:  115:
        -:  116:typedef void* _invalid_parameter_handler;
        -:  117:
        -:  118:inline _invalid_parameter_handler
        -:  119:_set_invalid_parameter_handler( _invalid_parameter_handler arg )
        -:  120:{
        -:  121:    return arg;
        -:  122:}
        -:  123:
        -:  124:#  endif
        -:  125:
        -:  126:#  if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x0564)) || defined(UNDER_CE)
        -:  127:
        -:  128:namespace { void _set_se_translator( void* ) {} }
        -:  129:
        -:  130:#  endif
        -:  131:
        -:  132:#elif defined(BOOST_HAS_SIGACTION)
        -:  133:
        -:  134:#  define BOOST_SIGACTION_BASED_SIGNAL_HANDLING
        -:  135:
        -:  136:#  include <unistd.h>
        -:  137:#  include <signal.h>
        -:  138:#  include <setjmp.h>
        -:  139:
        -:  140:#  if defined(__FreeBSD__)
        -:  141:
        -:  142:#    include <osreldate.h>
        -:  143:
        -:  144:#    ifndef SIGPOLL
        -:  145:#      define SIGPOLL SIGIO
        -:  146:#    endif
        -:  147:
        -:  148:#    if (__FreeBSD_version < 70100)
        -:  149:
        -:  150:#      define ILL_ILLADR 0 // ILL_RESAD_FAULT
        -:  151:#      define ILL_PRVOPC ILL_PRIVIN_FAULT
        -:  152:#      define ILL_ILLOPN 2 // ILL_RESOP_FAULT
        -:  153:#      define ILL_COPROC ILL_FPOP_FAULT
        -:  154:
        -:  155:#      define BOOST_TEST_LIMITED_SIGNAL_DETAILS
        -:  156:
        -:  157:#    endif
        -:  158:#  endif
        -:  159:
        -:  160:#  if defined(__ANDROID__)
        -:  161:#    include <android/api-level.h>
        -:  162:#  endif
        -:  163:
        -:  164:// documentation of BOOST_TEST_DISABLE_ALT_STACK in execution_monitor.hpp
        -:  165:#  if !defined(__CYGWIN__) && !defined(__QNXNTO__) && !defined(__bgq__) && \
        -:  166:   (!defined(__ANDROID__) || __ANDROID_API__ >= 8) && \
        -:  167:   !defined(BOOST_TEST_DISABLE_ALT_STACK)
        -:  168:#    define BOOST_TEST_USE_ALT_STACK
        -:  169:#  endif
        -:  170:
        -:  171:#  if defined(SIGPOLL) && !defined(__CYGWIN__)                              && \
        -:  172:      !(defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__))  && \
        -:  173:      !defined(__NetBSD__)                                                  && \
        -:  174:      !defined(__QNXNTO__)
        -:  175:#    define BOOST_TEST_CATCH_SIGPOLL
        -:  176:#  endif
        -:  177:
        -:  178:#  ifdef BOOST_TEST_USE_ALT_STACK
        -:  179:#    define BOOST_TEST_ALT_STACK_SIZE SIGSTKSZ
        -:  180:#  endif
        -:  181:
        -:  182:
        -:  183:#else
        -:  184:
        -:  185:#  define BOOST_NO_SIGNAL_HANDLING
        -:  186:
        -:  187:#endif
        -:  188:
        -:  189:#ifndef UNDER_CE
        -:  190:#include <errno.h>
        -:  191:#endif
        -:  192:
        -:  193:#if !defined(BOOST_NO_TYPEID) && !defined(BOOST_NO_RTTI)
        -:  194:#  include <boost/core/demangle.hpp>
        -:  195:#endif
        -:  196:
        -:  197:#include <boost/test/detail/suppress_warnings.hpp>
        -:  198:
        -:  199://____________________________________________________________________________//
        -:  200:
        -:  201:namespace boost {
        -:  202:
        -:  203:// ************************************************************************** //
        -:  204:// **************                 throw_exception              ************** //
        -:  205:// ************************************************************************** //
        -:  206:
        -:  207:#ifdef BOOST_NO_EXCEPTIONS
        -:  208:void throw_exception( std::exception const & e ) { abort(); }
        -:  209:#endif
        -:  210:
        -:  211:// ************************************************************************** //
        -:  212:// **************                  report_error                ************** //
        -:  213:// ************************************************************************** //
        -:  214:
        -:  215:namespace detail {
        -:  216:
        -:  217:#ifdef __BORLANDC__
        -:  218:#  define BOOST_TEST_VSNPRINTF( a1, a2, a3, a4 ) std::vsnprintf( (a1), (a2), (a3), (a4) )
        -:  219:#elif BOOST_WORKAROUND(_MSC_VER, <= 1310) || \
        -:  220:      BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3000)) || \
        -:  221:      defined(UNDER_CE) || \
        -:  222:      (defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR))
        -:  223:#  define BOOST_TEST_VSNPRINTF( a1, a2, a3, a4 ) _vsnprintf( (a1), (a2), (a3), (a4) )
        -:  224:#else
        -:  225:#  define BOOST_TEST_VSNPRINTF( a1, a2, a3, a4 ) vsnprintf( (a1), (a2), (a3), (a4) )
        -:  226:#endif
        -:  227:
        -:  228:#ifndef BOOST_NO_EXCEPTIONS
        -:  229:
        -:  230:template <typename ErrorInfo>
        -:  231:typename ErrorInfo::value_type
    #####:  232:extract( boost::exception const* ex )
        -:  233:{
    #####:  234:    if( !ex )
    #####:  235:        return 0;
        -:  236:
    #####:  237:    typename ErrorInfo::value_type const * val = boost::get_error_info<ErrorInfo>( *ex );
        -:  238:
    #####:  239:    return val ? *val : 0;
        -:  240:}
------------------
_ZN5boost6detail7extractINS_10error_infoINS_15throw_function_EPKcEEEENT_10value_typeEPKNS_9exceptionE:
    #####:  232:extract( boost::exception const* ex )
        -:  233:{
    #####:  234:    if( !ex )
    %%%%%:  234-block  0
    #####:  235:        return 0;
    %%%%%:  235-block  0
        -:  236:
    #####:  237:    typename ErrorInfo::value_type const * val = boost::get_error_info<ErrorInfo>( *ex );
    %%%%%:  237-block  0
        -:  238:
    #####:  239:    return val ? *val : 0;
    %%%%%:  239-block  0
    %%%%%:  239-block  1
    %%%%%:  239-block  2
        -:  240:}
------------------
_ZN5boost6detail7extractINS_10error_infoINS_11throw_line_EiEEEENT_10value_typeEPKNS_9exceptionE:
    #####:  232:extract( boost::exception const* ex )
        -:  233:{
    #####:  234:    if( !ex )
    %%%%%:  234-block  0
    #####:  235:        return 0;
    %%%%%:  235-block  0
        -:  236:
    #####:  237:    typename ErrorInfo::value_type const * val = boost::get_error_info<ErrorInfo>( *ex );
    %%%%%:  237-block  0
        -:  238:
    #####:  239:    return val ? *val : 0;
    %%%%%:  239-block  0
    %%%%%:  239-block  1
    %%%%%:  239-block  2
        -:  240:}
------------------
_ZN5boost6detail7extractINS_10error_infoINS_11throw_file_EPKcEEEENT_10value_typeEPKNS_9exceptionE:
    #####:  232:extract( boost::exception const* ex )
        -:  233:{
    #####:  234:    if( !ex )
    %%%%%:  234-block  0
    #####:  235:        return 0;
    %%%%%:  235-block  0
        -:  236:
    #####:  237:    typename ErrorInfo::value_type const * val = boost::get_error_info<ErrorInfo>( *ex );
    %%%%%:  237-block  0
        -:  238:
    #####:  239:    return val ? *val : 0;
    %%%%%:  239-block  0
    %%%%%:  239-block  1
    %%%%%:  239-block  2
        -:  240:}
------------------
        -:  241:
        -:  242://____________________________________________________________________________//
        -:  243:
        -:  244:static void
    #####:  245:report_error( execution_exception::error_code ec, boost::exception const* be, char const* format, va_list* args )
        -:  246:{
        -:  247:    static const int REPORT_ERROR_BUFFER_SIZE = 4096;
        -:  248:    static char buf[REPORT_ERROR_BUFFER_SIZE];
        -:  249:
    #####:  250:    BOOST_TEST_VSNPRINTF( buf, sizeof(buf)-1, format, *args );
    %%%%%:  250-block  0
    #####:  251:    buf[sizeof(buf)-1] = 0;
        -:  252:
    #####:  253:    va_end( *args );
        -:  254:
    #####:  255:    BOOST_TEST_I_THROW(execution_exception( ec, buf, execution_exception::location( extract<throw_file>( be ),
    %%%%%:  255-block  0
    %%%%%:  255-block  1
    $$$$$:  255-block  2
    $$$$$:  255-block  3
        -:  256:                                                                                    (size_t)extract<throw_line>( be ),
        -:  257:                                                                                    extract<throw_function>( be ) ) ));
        -:  258:}
        -:  259:
        -:  260://____________________________________________________________________________//
        -:  261:
        -:  262:static void
    #####:  263:report_error( execution_exception::error_code ec, boost::exception const* be, char const* format, ... )
        -:  264:{
        -:  265:    va_list args;
    #####:  266:    va_start( args, format );
        -:  267:
    #####:  268:    report_error( ec, be, format, &args );
    %%%%%:  268-block  0
    #####:  269:}
    %%%%%:  269-block  0
        -:  270:
        -:  271:#endif
        -:  272:
        -:  273://____________________________________________________________________________//
        -:  274:
        -:  275:static void
    #####:  276:report_error( execution_exception::error_code ec, char const* format, ... )
        -:  277:{
        -:  278:    va_list args;
    #####:  279:    va_start( args, format );
        -:  280:
    #####:  281:    report_error( ec, 0, format, &args );
    %%%%%:  281-block  0
    #####:  282:}
    %%%%%:  282-block  0
        -:  283:
        -:  284://____________________________________________________________________________//
        -:  285:
        -:  286:template<typename Tr,typename Functor>
        -:  287:inline int
       14:  288:do_invoke( Tr const& tr, Functor const& F )
        -:  289:{
      14*:  290:    return tr ? (*tr)( F ) : F();
       14:  290-block  0
    %%%%%:  290-block  1
       14:  290-block  2
       14:  290-block  3
        -:  291:}
        -:  292:
        -:  293://____________________________________________________________________________//
        -:  294:
        -:  295:struct fpe_except_guard {
       14:  296:    explicit fpe_except_guard( unsigned detect_fpe )
       14:  297:    : m_detect_fpe( detect_fpe )
        -:  298:    {
        -:  299:        // prepare fp exceptions control
       14:  300:        m_previously_enabled = fpe::disable( fpe::BOOST_FPE_ALL );
       14:  300-block  0
      14*:  301:        if( m_previously_enabled != fpe::BOOST_FPE_INV && detect_fpe != fpe::BOOST_FPE_OFF )
    %%%%%:  301-block  0
    #####:  302:            fpe::enable( detect_fpe );
    %%%%%:  302-block  0
       14:  303:    }
       14:  304:    ~fpe_except_guard()
       14:  305:    {
       14:  306:        if( m_detect_fpe != fpe::BOOST_FPE_OFF )
       14:  306-block  0
    #####:  307:            fpe::disable( m_detect_fpe );
    %%%%%:  307-block  0
       14:  308:        if( m_previously_enabled != fpe::BOOST_FPE_INV )
       14:  308-block  0
    #####:  309:            fpe::enable( m_previously_enabled );
    %%%%%:  309-block  0
       14:  310:    }
        -:  311:
        -:  312:    unsigned m_detect_fpe;
        -:  313:    unsigned m_previously_enabled;
        -:  314:};
        -:  315:
        -:  316:
        -:  317:// ************************************************************************** //
        -:  318:// **************                  typeid_name                 ************** //
        -:  319:// ************************************************************************** //
        -:  320:
        -:  321:#if !defined(BOOST_NO_TYPEID) && !defined(BOOST_NO_RTTI)
        -:  322:template<typename T>
        -:  323:std::string
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt9exceptionEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt13runtime_errorEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt11logic_errorEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt15underflow_errorEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt14overflow_errorEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt11range_errorEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt12out_of_rangeEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt12length_errorEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt16invalid_argumentEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt12domain_errorEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt13bad_exceptionEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt10bad_typeidEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt8bad_castEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
_ZN5boost6detail11typeid_nameISt9bad_allocEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  324:typeid_name( T const& t )
        -:  325:{
    #####:  326:    return boost::core::demangle(typeid(t).name());
    %%%%%:  326-block  0
        -:  327:}
------------------
        -:  328:#endif
        -:  329:
        -:  330:} // namespace detail
        -:  331:
        -:  332:#if defined(BOOST_SIGACTION_BASED_SIGNAL_HANDLING)
        -:  333:
        -:  334:// ************************************************************************** //
        -:  335:// **************       Sigaction based signal handling        ************** //
        -:  336:// ************************************************************************** //
        -:  337:
        -:  338:namespace detail {
        -:  339:
        -:  340:// ************************************************************************** //
        -:  341:// **************    boost::detail::system_signal_exception    ************** //
        -:  342:// ************************************************************************** //
        -:  343:
        -:  344:class system_signal_exception {
        -:  345:public:
        -:  346:    // Constructor
        -:  347:    system_signal_exception()
        -:  348:    : m_sig_info( 0 )
        -:  349:    , m_context( 0 )
        -:  350:    {}
        -:  351:
        -:  352:    // Access methods
        -:  353:    void        operator()( siginfo_t* i, void* c )
        -:  354:    {
        -:  355:        m_sig_info  = i;
        -:  356:        m_context   = c;
        -:  357:    }
        -:  358:    void        report() const;
        -:  359:
        -:  360:private:
        -:  361:    // Data members
        -:  362:    siginfo_t*  m_sig_info; // system signal detailed info
        -:  363:    void*       m_context;  // signal context
        -:  364:};
        -:  365:
        -:  366://____________________________________________________________________________//
        -:  367:
        -:  368:void
        -:  369:system_signal_exception::report() const
        -:  370:{
        -:  371:    if( !m_sig_info )
        -:  372:        return; // no error actually occur?
        -:  373:
        -:  374:    switch( m_sig_info->si_code ) {
        -:  375:#ifdef __VXWORKS__
        -:  376:// a bit of a hack to adapt code to small m_sig_info VxWorks uses
        -:  377:#define si_addr si_value.sival_int
        -:  378:#define si_band si_value.sival_int
        -:  379:#else
        -:  380:    case SI_USER:
        -:  381:        report_error( execution_exception::system_error,
        -:  382:                      "signal: generated by kill() (or family); uid=%d; pid=%d",
        -:  383:                      (int)m_sig_info->si_uid, (int)m_sig_info->si_pid );
        -:  384:        break;
        -:  385:#endif
        -:  386:    case SI_QUEUE:
        -:  387:        report_error( execution_exception::system_error,
        -:  388:                      "signal: sent by sigqueue()" );
        -:  389:        break;
        -:  390:    case SI_TIMER:
        -:  391:        report_error( execution_exception::system_error,
        -:  392:                      "signal: the expiration of a timer set by timer_settimer()" );
        -:  393:        break;
        -:  394:    case SI_ASYNCIO:
        -:  395:        report_error( execution_exception::system_error,
        -:  396:                      "signal: generated by the completion of an asynchronous I/O request" );
        -:  397:        break;
        -:  398:    case SI_MESGQ:
        -:  399:        report_error( execution_exception::system_error,
        -:  400:                      "signal: generated by the the arrival of a message on an empty message queue" );
        -:  401:        break;
        -:  402:    default:
        -:  403:        break;
        -:  404:    }
        -:  405:
        -:  406:    switch( m_sig_info->si_signo ) {
        -:  407:    case SIGILL:
        -:  408:        switch( m_sig_info->si_code ) {
        -:  409:#ifndef BOOST_TEST_LIMITED_SIGNAL_DETAILS
        -:  410:        case ILL_ILLOPC:
        -:  411:            report_error( execution_exception::system_fatal_error,
        -:  412:                          "signal: illegal opcode; address of failing instruction: 0x%08lx",
        -:  413:                          m_sig_info->si_addr );
        -:  414:            break;
        -:  415:        case ILL_ILLTRP:
        -:  416:            report_error( execution_exception::system_fatal_error,
        -:  417:                          "signal: illegal trap; address of failing instruction: 0x%08lx",
        -:  418:                          m_sig_info->si_addr );
        -:  419:            break;
        -:  420:        case ILL_PRVREG:
        -:  421:            report_error( execution_exception::system_fatal_error,
        -:  422:                          "signal: privileged register; address of failing instruction: 0x%08lx",
        -:  423:                          m_sig_info->si_addr );
        -:  424:            break;
        -:  425:        case ILL_BADSTK:
        -:  426:            report_error( execution_exception::system_fatal_error,
        -:  427:                          "signal: internal stack error; address of failing instruction: 0x%08lx",
        -:  428:                          m_sig_info->si_addr );
        -:  429:            break;
        -:  430:#endif
        -:  431:        case ILL_ILLOPN:
        -:  432:            report_error( execution_exception::system_fatal_error,
        -:  433:                          "signal: illegal operand; address of failing instruction: 0x%08lx",
        -:  434:                          m_sig_info->si_addr );
        -:  435:            break;
        -:  436:        case ILL_ILLADR:
        -:  437:            report_error( execution_exception::system_fatal_error,
        -:  438:                          "signal: illegal addressing mode; address of failing instruction: 0x%08lx",
        -:  439:                          m_sig_info->si_addr );
        -:  440:            break;
        -:  441:        case ILL_PRVOPC:
        -:  442:            report_error( execution_exception::system_fatal_error,
        -:  443:                          "signal: privileged opcode; address of failing instruction: 0x%08lx",
        -:  444:                          m_sig_info->si_addr );
        -:  445:            break;
        -:  446:        case ILL_COPROC:
        -:  447:            report_error( execution_exception::system_fatal_error,
        -:  448:                          "signal: co-processor error; address of failing instruction: 0x%08lx",
        -:  449:                          m_sig_info->si_addr );
        -:  450:            break;
        -:  451:        default:
        -:  452:            report_error( execution_exception::system_fatal_error,
        -:  453:                          "signal: SIGILL, si_code: %d (illegal instruction; address of failing instruction: 0x%08lx)",
        -:  454:                          m_sig_info->si_addr, m_sig_info->si_code );
        -:  455:            break;
        -:  456:        }
        -:  457:        break;
        -:  458:
        -:  459:    case SIGFPE:
        -:  460:        switch( m_sig_info->si_code ) {
        -:  461:        case FPE_INTDIV:
        -:  462:            report_error( execution_exception::system_error,
        -:  463:                          "signal: integer divide by zero; address of failing instruction: 0x%08lx",
        -:  464:                          m_sig_info->si_addr );
        -:  465:            break;
        -:  466:        case FPE_INTOVF:
        -:  467:            report_error( execution_exception::system_error,
        -:  468:                          "signal: integer overflow; address of failing instruction: 0x%08lx",
        -:  469:                          m_sig_info->si_addr );
        -:  470:            break;
        -:  471:        case FPE_FLTDIV:
        -:  472:            report_error( execution_exception::system_error,
        -:  473:                          "signal: floating point divide by zero; address of failing instruction: 0x%08lx",
        -:  474:                          m_sig_info->si_addr );
        -:  475:            break;
        -:  476:        case FPE_FLTOVF:
        -:  477:            report_error( execution_exception::system_error,
        -:  478:                          "signal: floating point overflow; address of failing instruction: 0x%08lx",
        -:  479:                          m_sig_info->si_addr );
        -:  480:            break;
        -:  481:        case FPE_FLTUND:
        -:  482:            report_error( execution_exception::system_error,
        -:  483:                          "signal: floating point underflow; address of failing instruction: 0x%08lx",
        -:  484:                          m_sig_info->si_addr );
        -:  485:            break;
        -:  486:        case FPE_FLTRES:
        -:  487:            report_error( execution_exception::system_error,
        -:  488:                          "signal: floating point inexact result; address of failing instruction: 0x%08lx",
        -:  489:                          m_sig_info->si_addr );
        -:  490:            break;
        -:  491:        case FPE_FLTINV:
        -:  492:            report_error( execution_exception::system_error,
        -:  493:                          "signal: invalid floating point operation; address of failing instruction: 0x%08lx",
        -:  494:                          m_sig_info->si_addr );
        -:  495:            break;
        -:  496:        case FPE_FLTSUB:
        -:  497:            report_error( execution_exception::system_error,
        -:  498:                          "signal: subscript out of range; address of failing instruction: 0x%08lx",
        -:  499:                          m_sig_info->si_addr );
        -:  500:            break;
        -:  501:        default:
        -:  502:            report_error( execution_exception::system_error,
        -:  503:                          "signal: SIGFPE, si_code: %d (errnoneous arithmetic operations; address of failing instruction: 0x%08lx)",
        -:  504:                          m_sig_info->si_addr, m_sig_info->si_code );
        -:  505:            break;
        -:  506:        }
        -:  507:        break;
        -:  508:
        -:  509:    case SIGSEGV:
        -:  510:        switch( m_sig_info->si_code ) {
        -:  511:#ifndef BOOST_TEST_LIMITED_SIGNAL_DETAILS
        -:  512:        case SEGV_MAPERR:
        -:  513:            report_error( execution_exception::system_fatal_error,
        -:  514:                          "memory access violation at address: 0x%08lx: no mapping at fault address",
        -:  515:                          m_sig_info->si_addr );
        -:  516:            break;
        -:  517:        case SEGV_ACCERR:
        -:  518:            report_error( execution_exception::system_fatal_error,
        -:  519:                          "memory access violation at address: 0x%08lx: invalid permissions",
        -:  520:                          m_sig_info->si_addr );
        -:  521:            break;
        -:  522:#endif
        -:  523:        default:
        -:  524:            report_error( execution_exception::system_fatal_error,
        -:  525:                          "signal: SIGSEGV, si_code: %d (memory access violation at address: 0x%08lx)",
        -:  526:                          m_sig_info->si_addr, m_sig_info->si_code );
        -:  527:            break;
        -:  528:        }
        -:  529:        break;
        -:  530:
        -:  531:    case SIGBUS:
        -:  532:        switch( m_sig_info->si_code ) {
        -:  533:#ifndef BOOST_TEST_LIMITED_SIGNAL_DETAILS
        -:  534:        case BUS_ADRALN:
        -:  535:            report_error( execution_exception::system_fatal_error,
        -:  536:                          "memory access violation at address: 0x%08lx: invalid address alignment",
        -:  537:                          m_sig_info->si_addr );
        -:  538:            break;
        -:  539:        case BUS_ADRERR:
        -:  540:            report_error( execution_exception::system_fatal_error,
        -:  541:                          "memory access violation at address: 0x%08lx: non-existent physical address",
        -:  542:                          m_sig_info->si_addr );
        -:  543:            break;
        -:  544:        case BUS_OBJERR:
        -:  545:            report_error( execution_exception::system_fatal_error,
        -:  546:                          "memory access violation at address: 0x%08lx: object specific hardware error",
        -:  547:                          m_sig_info->si_addr );
        -:  548:            break;
        -:  549:#endif
        -:  550:        default:
        -:  551:            report_error( execution_exception::system_fatal_error,
        -:  552:                          "signal: SIGSEGV, si_code: %d (memory access violation at address: 0x%08lx)",
        -:  553:                          m_sig_info->si_addr, m_sig_info->si_code );
        -:  554:            break;
        -:  555:        }
        -:  556:        break;
        -:  557:
        -:  558:#if defined(BOOST_TEST_CATCH_SIGPOLL)
        -:  559:
        -:  560:    case SIGPOLL:
        -:  561:        switch( m_sig_info->si_code ) {
        -:  562:#ifndef BOOST_TEST_LIMITED_SIGNAL_DETAILS
        -:  563:        case POLL_IN:
        -:  564:            report_error( execution_exception::system_error,
        -:  565:                          "data input available; band event %d",
        -:  566:                          (int)m_sig_info->si_band );
        -:  567:            break;
        -:  568:        case POLL_OUT:
        -:  569:            report_error( execution_exception::system_error,
        -:  570:                          "output buffers available; band event %d",
        -:  571:                          (int)m_sig_info->si_band );
        -:  572:            break;
        -:  573:        case POLL_MSG:
        -:  574:            report_error( execution_exception::system_error,
        -:  575:                          "input message available; band event %d",
        -:  576:                          (int)m_sig_info->si_band );
        -:  577:            break;
        -:  578:        case POLL_ERR:
        -:  579:            report_error( execution_exception::system_error,
        -:  580:                          "i/o error; band event %d",
        -:  581:                          (int)m_sig_info->si_band );
        -:  582:            break;
        -:  583:        case POLL_PRI:
        -:  584:            report_error( execution_exception::system_error,
        -:  585:                          "high priority input available; band event %d",
        -:  586:                          (int)m_sig_info->si_band );
        -:  587:            break;
        -:  588:#if defined(POLL_ERR) && defined(POLL_HUP) && (POLL_ERR - POLL_HUP)
        -:  589:        case POLL_HUP:
        -:  590:            report_error( execution_exception::system_error,
        -:  591:                          "device disconnected; band event %d",
        -:  592:                          (int)m_sig_info->si_band );
        -:  593:            break;
        -:  594:#endif
        -:  595:#endif
        -:  596:        default:
        -:  597:            report_error( execution_exception::system_error,
        -:  598:                          "signal: SIGPOLL, si_code: %d (asynchronous I/O event occurred; band event %d)",
        -:  599:                          (int)m_sig_info->si_band, m_sig_info->si_code );
        -:  600:            break;
        -:  601:        }
        -:  602:        break;
        -:  603:
        -:  604:#endif
        -:  605:
        -:  606:    case SIGABRT:
        -:  607:        report_error( execution_exception::system_error,
        -:  608:                      "signal: SIGABRT (application abort requested)" );
        -:  609:        break;
        -:  610:
        -:  611:    case SIGALRM:
        -:  612:        report_error( execution_exception::timeout_error,
        -:  613:                      "signal: SIGALRM (timeout while executing function)" );
        -:  614:        break;
        -:  615:
        -:  616:    default:
        -:  617:        report_error( execution_exception::system_error,
        -:  618:                      "unrecognized signal %d", m_sig_info->si_signo );
        -:  619:    }
        -:  620:}
        -:  621:
        -:  622://____________________________________________________________________________//
        -:  623:
        -:  624:// ************************************************************************** //
        -:  625:// **************         boost::detail::signal_action         ************** //
        -:  626:// ************************************************************************** //
        -:  627:
        -:  628:// Forward declaration
        -:  629:extern "C" {
        -:  630:static void boost_execution_monitor_jumping_signal_handler( int sig, siginfo_t* info, void* context );
        -:  631:static void boost_execution_monitor_attaching_signal_handler( int sig, siginfo_t* info, void* context );
        -:  632:}
        -:  633:
        -:  634:class signal_action {
        -:  635:    typedef struct sigaction* sigaction_ptr;
        -:  636:public:
        -:  637:    //Constructor
        -:  638:    signal_action();
        -:  639:    signal_action( int sig, bool install, bool attach_dbg, char* alt_stack );
        -:  640:    ~signal_action();
        -:  641:
        -:  642:private:
        -:  643:    // Data members
        -:  644:    int                 m_sig;
        -:  645:    bool                m_installed;
        -:  646:    struct sigaction    m_new_action;
        -:  647:    struct sigaction    m_old_action;
        -:  648:};
        -:  649:
        -:  650://____________________________________________________________________________//
        -:  651:
        -:  652:signal_action::signal_action()
        -:  653:: m_installed( false )
        -:  654:{}
        -:  655:
        -:  656://____________________________________________________________________________//
        -:  657:
        -:  658:signal_action::signal_action( int sig, bool install, bool attach_dbg, char* alt_stack )
        -:  659:: m_sig( sig )
        -:  660:, m_installed( install )
        -:  661:{
        -:  662:    if( !install )
        -:  663:        return;
        -:  664:
        -:  665:    std::memset( &m_new_action, 0, sizeof(struct sigaction) );
        -:  666:
        -:  667:    BOOST_TEST_SYS_ASSERT( ::sigaction( m_sig , sigaction_ptr(), &m_new_action ) != -1 );
        -:  668:
        -:  669:    if( m_new_action.sa_sigaction || m_new_action.sa_handler ) {
        -:  670:        m_installed = false;
        -:  671:        return;
        -:  672:    }
        -:  673:
        -:  674:    m_new_action.sa_flags     |= SA_SIGINFO;
        -:  675:    m_new_action.sa_sigaction  = attach_dbg ? &boost_execution_monitor_attaching_signal_handler
        -:  676:                                            : &boost_execution_monitor_jumping_signal_handler;
        -:  677:    BOOST_TEST_SYS_ASSERT( sigemptyset( &m_new_action.sa_mask ) != -1 );
        -:  678:
        -:  679:#ifdef BOOST_TEST_USE_ALT_STACK
        -:  680:    if( alt_stack )
        -:  681:        m_new_action.sa_flags |= SA_ONSTACK;
        -:  682:#endif
        -:  683:
        -:  684:    BOOST_TEST_SYS_ASSERT( ::sigaction( m_sig, &m_new_action, &m_old_action ) != -1 );
        -:  685:}
        -:  686:
        -:  687://____________________________________________________________________________//
        -:  688:
        -:  689:signal_action::~signal_action()
        -:  690:{
        -:  691:    if( m_installed )
        -:  692:        ::sigaction( m_sig, &m_old_action , sigaction_ptr() );
        -:  693:}
        -:  694:
        -:  695://____________________________________________________________________________//
        -:  696:
        -:  697:// ************************************************************************** //
        -:  698:// **************        boost::detail::signal_handler         ************** //
        -:  699:// ************************************************************************** //
        -:  700:
        -:  701:class signal_handler {
        -:  702:public:
        -:  703:    // Constructor
        -:  704:    explicit signal_handler( bool catch_system_errors, bool detect_fpe, unsigned timeout_microseconds, bool attach_dbg, char* alt_stack );
        -:  705:
        -:  706:    // Destructor
        -:  707:    ~signal_handler();
        -:  708:
        -:  709:    // access methods
        -:  710:    static sigjmp_buf&      jump_buffer()
        -:  711:    {
        -:  712:        assert( !!s_active_handler );
        -:  713:
        -:  714:        return s_active_handler->m_sigjmp_buf;
        -:  715:    }
        -:  716:
        -:  717:    static system_signal_exception&  sys_sig()
        -:  718:    {
        -:  719:        assert( !!s_active_handler );
        -:  720:
        -:  721:        return s_active_handler->m_sys_sig;
        -:  722:    }
        -:  723:
        -:  724:private:
        -:  725:    // Data members
        -:  726:    signal_handler*         m_prev_handler;
        -:  727:    unsigned                m_timeout_microseconds;
        -:  728:
        -:  729:    // Note: We intentionality do not catch SIGCHLD. Users have to deal with it themselves
        -:  730:    signal_action           m_ILL_action;
        -:  731:    signal_action           m_FPE_action;
        -:  732:    signal_action           m_SEGV_action;
        -:  733:    signal_action           m_BUS_action;
        -:  734:    signal_action           m_CHLD_action;
        -:  735:    signal_action           m_POLL_action;
        -:  736:    signal_action           m_ABRT_action;
        -:  737:    signal_action           m_ALRM_action;
        -:  738:
        -:  739:    sigjmp_buf              m_sigjmp_buf;
        -:  740:    system_signal_exception m_sys_sig;
        -:  741:
        -:  742:    static signal_handler*  s_active_handler;
        -:  743:};
        -:  744:
        -:  745:// !! need to be placed in thread specific storage
        -:  746:typedef signal_handler* signal_handler_ptr;
        -:  747:signal_handler* signal_handler::s_active_handler = signal_handler_ptr();
        -:  748:
        -:  749://____________________________________________________________________________//
        -:  750:
        -:  751:signal_handler::signal_handler( bool catch_system_errors, bool detect_fpe, unsigned timeout_microseconds, bool attach_dbg, char* alt_stack )
        -:  752:: m_prev_handler( s_active_handler )
        -:  753:, m_timeout_microseconds( timeout_microseconds )
        -:  754:, m_ILL_action ( SIGILL , catch_system_errors,      attach_dbg, alt_stack )
        -:  755:, m_FPE_action ( SIGFPE , detect_fpe         ,      attach_dbg, alt_stack )
        -:  756:, m_SEGV_action( SIGSEGV, catch_system_errors,      attach_dbg, alt_stack )
        -:  757:, m_BUS_action ( SIGBUS , catch_system_errors,      attach_dbg, alt_stack )
        -:  758:#ifdef BOOST_TEST_CATCH_SIGPOLL
        -:  759:, m_POLL_action( SIGPOLL, catch_system_errors,      attach_dbg, alt_stack )
        -:  760:#endif
        -:  761:, m_ABRT_action( SIGABRT, catch_system_errors,      attach_dbg, alt_stack )
        -:  762:, m_ALRM_action( SIGALRM, timeout_microseconds > 0, attach_dbg, alt_stack )
        -:  763:{
        -:  764:    s_active_handler = this;
        -:  765:
        -:  766:    if( m_timeout_microseconds > 0 ) {
        -:  767:        ::alarm( 0 );
        -:  768:        ::alarm( static_cast<unsigned int>(std::ceil(timeout_microseconds / 1E6) )); // alarm has a precision to the seconds
        -:  769:    }
        -:  770:
        -:  771:#ifdef BOOST_TEST_USE_ALT_STACK
        -:  772:    if( alt_stack ) {
        -:  773:        stack_t sigstk;
        -:  774:        std::memset( &sigstk, 0, sizeof(stack_t) );
        -:  775:
        -:  776:        BOOST_TEST_SYS_ASSERT( ::sigaltstack( 0, &sigstk ) != -1 );
        -:  777:
        -:  778:        if( sigstk.ss_flags & SS_DISABLE ) {
        -:  779:            sigstk.ss_sp    = alt_stack;
        -:  780:            sigstk.ss_size  = BOOST_TEST_ALT_STACK_SIZE;
        -:  781:            sigstk.ss_flags = 0;
        -:  782:            BOOST_TEST_SYS_ASSERT( ::sigaltstack( &sigstk, 0 ) != -1 );
        -:  783:        }
        -:  784:    }
        -:  785:#endif
        -:  786:}
        -:  787:
        -:  788://____________________________________________________________________________//
        -:  789:
        -:  790:signal_handler::~signal_handler()
        -:  791:{
        -:  792:    assert( s_active_handler == this );
        -:  793:
        -:  794:    if( m_timeout_microseconds > 0 )
        -:  795:        ::alarm( 0 );
        -:  796:
        -:  797:#ifdef BOOST_TEST_USE_ALT_STACK
        -:  798:#ifdef __GNUC__
        -:  799:    // We shouldn't need to explicitly initialize all the members here,
        -:  800:    // but gcc warns if we don't, so add initializers for each of the
        -:  801:    // members specified in the POSIX std:
        -:  802:    stack_t sigstk = { 0, 0, 0 };
        -:  803:#else
        -:  804:    stack_t sigstk = { };
        -:  805:#endif
        -:  806:
        -:  807:    sigstk.ss_size  = MINSIGSTKSZ;
        -:  808:    sigstk.ss_flags = SS_DISABLE;
        -:  809:    if( ::sigaltstack( &sigstk, 0 ) == -1 ) {
        -:  810:        int error_n = errno;
        -:  811:        std::cerr << "******** errors disabling the alternate stack:" << std::endl
        -:  812:                  << "\t#error:" << error_n << std::endl
        -:  813:                  << "\t" << std::strerror( error_n ) << std::endl;
        -:  814:    }
        -:  815:#endif
        -:  816:
        -:  817:    s_active_handler = m_prev_handler;
        -:  818:}
        -:  819:
        -:  820://____________________________________________________________________________//
        -:  821:
        -:  822:// ************************************************************************** //
        -:  823:// **************       execution_monitor_signal_handler       ************** //
        -:  824:// ************************************************************************** //
        -:  825:
        -:  826:extern "C" {
        -:  827:
        -:  828:static void boost_execution_monitor_jumping_signal_handler( int sig, siginfo_t* info, void* context )
        -:  829:{
        -:  830:    signal_handler::sys_sig()( info, context );
        -:  831:
        -:  832:    siglongjmp( signal_handler::jump_buffer(), sig );
        -:  833:}
        -:  834:
        -:  835://____________________________________________________________________________//
        -:  836:
        -:  837:static void boost_execution_monitor_attaching_signal_handler( int sig, siginfo_t* info, void* context )
        -:  838:{
        -:  839:    if( !debug::attach_debugger( false ) )
        -:  840:        boost_execution_monitor_jumping_signal_handler( sig, info, context );
        -:  841:
        -:  842:    // debugger attached; it will handle the signal
        -:  843:    BOOST_TEST_SYS_ASSERT( ::signal( sig, SIG_DFL ) != SIG_ERR );
        -:  844:}
        -:  845:
        -:  846://____________________________________________________________________________//
        -:  847:
        -:  848:}
        -:  849:
        -:  850:} // namespace detail
        -:  851:
        -:  852:// ************************************************************************** //
        -:  853:// **************        execution_monitor::catch_signals      ************** //
        -:  854:// ************************************************************************** //
        -:  855:
        -:  856:int
        -:  857:execution_monitor::catch_signals( boost::function<int ()> const& F )
        -:  858:{
        -:  859:    using namespace detail;
        -:  860:
        -:  861:#if defined(__CYGWIN__)
        -:  862:    p_catch_system_errors.value = false;
        -:  863:#endif
        -:  864:
        -:  865:#ifdef BOOST_TEST_USE_ALT_STACK
        -:  866:    if( !!p_use_alt_stack && !m_alt_stack )
        -:  867:        m_alt_stack.reset( new char[BOOST_TEST_ALT_STACK_SIZE] );
        -:  868:#else
        -:  869:    p_use_alt_stack.value = false;
        -:  870:#endif
        -:  871:
        -:  872:    signal_handler local_signal_handler( p_catch_system_errors,
        -:  873:                                         p_catch_system_errors || (p_detect_fp_exceptions != fpe::BOOST_FPE_OFF),
        -:  874:                                         p_timeout,
        -:  875:                                         p_auto_start_dbg,
        -:  876:                                         !p_use_alt_stack ? 0 : m_alt_stack.get() );
        -:  877:
        -:  878:    if( !sigsetjmp( signal_handler::jump_buffer(), 1 ) )
        -:  879:        return detail::do_invoke( m_custom_translators , F );
        -:  880:    else
        -:  881:        BOOST_TEST_I_THROW( local_signal_handler.sys_sig() );
        -:  882:}
        -:  883:
        -:  884://____________________________________________________________________________//
        -:  885:
        -:  886:#elif defined(BOOST_SEH_BASED_SIGNAL_HANDLING)
        -:  887:
        -:  888:// ************************************************************************** //
        -:  889:// **************   Microsoft structured exception handling    ************** //
        -:  890:// ************************************************************************** //
        -:  891:
        -:  892:#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x0564))
        -:  893:namespace { void _set_se_translator( void* ) {} }
        -:  894:#endif
        -:  895:
        -:  896:namespace detail {
        -:  897:
        -:  898:// ************************************************************************** //
        -:  899:// **************    boost::detail::system_signal_exception    ************** //
        -:  900:// ************************************************************************** //
        -:  901:
        -:  902:class system_signal_exception {
        -:  903:public:
        -:  904:    // Constructor
        -:  905:    explicit            system_signal_exception( execution_monitor* em )
        -:  906:    : m_em( em )
        -:  907:    , m_se_id( 0 )
        -:  908:    , m_fault_address( 0 )
        -:  909:    , m_dir( false )
        -:  910:    , m_timeout( false )
        -:  911:    {}
        -:  912:
        -:  913:    void                set_timed_out();
        -:  914:    void                report() const;
        -:  915:    int                 operator()( unsigned id, _EXCEPTION_POINTERS* exps );
        -:  916:
        -:  917:private:
        -:  918:    // Data members
        -:  919:    execution_monitor*  m_em;
        -:  920:
        -:  921:    unsigned            m_se_id;
        -:  922:    void*               m_fault_address;
        -:  923:    bool                m_dir;
        -:  924:    bool                m_timeout;
        -:  925:};
        -:  926:
        -:  927://____________________________________________________________________________//
        -:  928:
        -:  929:#if BOOST_WORKAROUND( BOOST_MSVC, <= 1310)
        -:  930:static void
        -:  931:seh_catch_preventer( unsigned /* id */, _EXCEPTION_POINTERS* /* exps */ )
        -:  932:{
        -:  933:    throw;
        -:  934:}
        -:  935:#endif
        -:  936:
        -:  937://____________________________________________________________________________//
        -:  938:
        -:  939:void
        -:  940:system_signal_exception::set_timed_out()
        -:  941:{
        -:  942:    m_timeout = true;
        -:  943:}
        -:  944:
        -:  945://____________________________________________________________________________//
        -:  946:
        -:  947:int
        -:  948:system_signal_exception::operator()( unsigned id, _EXCEPTION_POINTERS* exps )
        -:  949:{
        -:  950:    const unsigned MSFT_CPP_EXCEPT = 0xE06d7363; // EMSC
        -:  951:
        -:  952:    // C++ exception - allow to go through
        -:  953:    if( id == MSFT_CPP_EXCEPT )
        -:  954:        return EXCEPTION_CONTINUE_SEARCH;
        -:  955:
        -:  956:    // FPE detection is enabled, while system exception detection is not - check if this is actually FPE
        -:  957:    if( !m_em->p_catch_system_errors ) {
        -:  958:        if( !m_em->p_detect_fp_exceptions )
        -:  959:            return EXCEPTION_CONTINUE_SEARCH;
        -:  960:
        -:  961:        switch( id ) {
        -:  962:        case EXCEPTION_FLT_DIVIDE_BY_ZERO:
        -:  963:        case EXCEPTION_FLT_STACK_CHECK:
        -:  964:        case EXCEPTION_FLT_DENORMAL_OPERAND:
        -:  965:        case EXCEPTION_FLT_INEXACT_RESULT:
        -:  966:        case EXCEPTION_FLT_OVERFLOW:
        -:  967:        case EXCEPTION_FLT_UNDERFLOW:
        -:  968:        case EXCEPTION_FLT_INVALID_OPERATION:
        -:  969:        case STATUS_FLOAT_MULTIPLE_FAULTS:
        -:  970:        case STATUS_FLOAT_MULTIPLE_TRAPS:
        -:  971:            break;
        -:  972:        default:
        -:  973:            return EXCEPTION_CONTINUE_SEARCH;
        -:  974:        }
        -:  975:    }
        -:  976:
        -:  977:    if( !!m_em->p_auto_start_dbg && debug::attach_debugger( false ) ) {
        -:  978:        m_em->p_catch_system_errors.value = false;
        -:  979:#if BOOST_WORKAROUND( BOOST_MSVC, <= 1310)
        -:  980:        _set_se_translator( &seh_catch_preventer );
        -:  981:#endif
        -:  982:        return EXCEPTION_CONTINUE_EXECUTION;
        -:  983:    }
        -:  984:
        -:  985:    m_se_id = id;
        -:  986:    if( m_se_id == EXCEPTION_ACCESS_VIOLATION && exps->ExceptionRecord->NumberParameters == 2 ) {
        -:  987:        m_fault_address = (void*)exps->ExceptionRecord->ExceptionInformation[1];
        -:  988:        m_dir           = exps->ExceptionRecord->ExceptionInformation[0] == 0;
        -:  989:    }
        -:  990:
        -:  991:    return EXCEPTION_EXECUTE_HANDLER;
        -:  992:}
        -:  993:
        -:  994://____________________________________________________________________________//
        -:  995:
        -:  996:void
        -:  997:system_signal_exception::report() const
        -:  998:{
        -:  999:    switch( m_se_id ) {
        -: 1000:    // cases classified as system_fatal_error
        -: 1001:    case EXCEPTION_ACCESS_VIOLATION: {
        -: 1002:        if( !m_fault_address )
        -: 1003:            detail::report_error( execution_exception::system_fatal_error, "memory access violation" );
        -: 1004:        else
        -: 1005:            detail::report_error(
        -: 1006:                execution_exception::system_fatal_error,
        -: 1007:                    "memory access violation occurred at address 0x%08lx, while attempting to %s",
        -: 1008:                    m_fault_address,
        -: 1009:                    m_dir ? " read inaccessible data"
        -: 1010:                          : " write to an inaccessible (or protected) address"
        -: 1011:                    );
        -: 1012:        break;
        -: 1013:    }
        -: 1014:
        -: 1015:    case EXCEPTION_ILLEGAL_INSTRUCTION:
        -: 1016:        detail::report_error( execution_exception::system_fatal_error, "illegal instruction" );
        -: 1017:        break;
        -: 1018:
        -: 1019:    case EXCEPTION_PRIV_INSTRUCTION:
        -: 1020:        detail::report_error( execution_exception::system_fatal_error, "tried to execute an instruction whose operation is not allowed in the current machine mode" );
        -: 1021:        break;
        -: 1022:
        -: 1023:    case EXCEPTION_IN_PAGE_ERROR:
        -: 1024:        detail::report_error( execution_exception::system_fatal_error, "access to a memory page that is not present" );
        -: 1025:        break;
        -: 1026:
        -: 1027:    case EXCEPTION_STACK_OVERFLOW:
        -: 1028:        detail::report_error( execution_exception::system_fatal_error, "stack overflow" );
        -: 1029:        break;
        -: 1030:
        -: 1031:    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
        -: 1032:        detail::report_error( execution_exception::system_fatal_error, "tried to continue execution after a non continuable exception occurred" );
        -: 1033:        break;
        -: 1034:
        -: 1035:    // cases classified as (non-fatal) system_trap
        -: 1036:    case EXCEPTION_DATATYPE_MISALIGNMENT:
        -: 1037:        detail::report_error( execution_exception::system_error, "data misalignment" );
        -: 1038:        break;
        -: 1039:
        -: 1040:    case EXCEPTION_INT_DIVIDE_BY_ZERO:
        -: 1041:        detail::report_error( execution_exception::system_error, "integer divide by zero" );
        -: 1042:        break;
        -: 1043:
        -: 1044:    case EXCEPTION_INT_OVERFLOW:
        -: 1045:        detail::report_error( execution_exception::system_error, "integer overflow" );
        -: 1046:        break;
        -: 1047:
        -: 1048:    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
        -: 1049:        detail::report_error( execution_exception::system_error, "array bounds exceeded" );
        -: 1050:        break;
        -: 1051:
        -: 1052:    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
        -: 1053:        detail::report_error( execution_exception::system_error, "floating point divide by zero" );
        -: 1054:        break;
        -: 1055:
        -: 1056:    case EXCEPTION_FLT_STACK_CHECK:
        -: 1057:        detail::report_error( execution_exception::system_error,
        -: 1058:                              "stack overflowed or underflowed as the result of a floating-point operation" );
        -: 1059:        break;
        -: 1060:
        -: 1061:    case EXCEPTION_FLT_DENORMAL_OPERAND:
        -: 1062:        detail::report_error( execution_exception::system_error,
        -: 1063:                              "operand of floating point operation is denormal" );
        -: 1064:        break;
        -: 1065:
        -: 1066:    case EXCEPTION_FLT_INEXACT_RESULT:
        -: 1067:        detail::report_error( execution_exception::system_error,
        -: 1068:                              "result of a floating-point operation cannot be represented exactly" );
        -: 1069:        break;
        -: 1070:
        -: 1071:    case EXCEPTION_FLT_OVERFLOW:
        -: 1072:        detail::report_error( execution_exception::system_error,
        -: 1073:                              "exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type" );
        -: 1074:        break;
        -: 1075:
        -: 1076:    case EXCEPTION_FLT_UNDERFLOW:
        -: 1077:        detail::report_error( execution_exception::system_error,
        -: 1078:                              "exponent of a floating-point operation is less than the magnitude allowed by the corresponding type" );
        -: 1079:        break;
        -: 1080:
        -: 1081:    case EXCEPTION_FLT_INVALID_OPERATION:
        -: 1082:        detail::report_error( execution_exception::system_error, "floating point error" );
        -: 1083:        break;
        -: 1084:
        -: 1085:    case STATUS_FLOAT_MULTIPLE_FAULTS:
        -: 1086:        detail::report_error( execution_exception::system_error, "multiple floating point errors" );
        -: 1087:        break;
        -: 1088:
        -: 1089:    case STATUS_FLOAT_MULTIPLE_TRAPS:
        -: 1090:        detail::report_error( execution_exception::system_error, "multiple floating point errors" );
        -: 1091:        break;
        -: 1092:
        -: 1093:    case EXCEPTION_BREAKPOINT:
        -: 1094:        detail::report_error( execution_exception::system_error, "breakpoint encountered" );
        -: 1095:        break;
        -: 1096:
        -: 1097:    default:
        -: 1098:        if( m_timeout ) {
        -: 1099:            detail::report_error(execution_exception::timeout_error, "timeout while executing function");
        -: 1100:        }
        -: 1101:        else {
        -: 1102:            detail::report_error( execution_exception::system_error, "unrecognized exception. Id: 0x%08lx", m_se_id );
        -: 1103:        }
        -: 1104:        break;
        -: 1105:    }
        -: 1106:}
        -: 1107:
        -: 1108://____________________________________________________________________________//
        -: 1109:
        -: 1110:// ************************************************************************** //
        -: 1111:// **************          assert_reporting_function           ************** //
        -: 1112:// ************************************************************************** //
        -: 1113:
        -: 1114:int BOOST_TEST_CALL_DECL
        -: 1115:assert_reporting_function( int reportType, char* userMessage, int* )
        -: 1116:{
        -: 1117:    // write this way instead of switch to avoid unreachable statements
        -: 1118:    if( reportType == BOOST_TEST_CRT_ASSERT || reportType == BOOST_TEST_CRT_ERROR )
        -: 1119:        detail::report_error( reportType == BOOST_TEST_CRT_ASSERT ? execution_exception::user_error : execution_exception::system_error, userMessage );
        -: 1120:
        -: 1121:    return 0;
        -: 1122:} // assert_reporting_function
        -: 1123:
        -: 1124://____________________________________________________________________________//
        -: 1125:
        -: 1126:void BOOST_TEST_CALL_DECL
        -: 1127:invalid_param_handler( wchar_t const* /* expr */,
        -: 1128:                       wchar_t const* /* func */,
        -: 1129:                       wchar_t const* /* file */,
        -: 1130:                       unsigned       /* line */,
        -: 1131:                       uintptr_t      /* reserved */)
        -: 1132:{
        -: 1133:    detail::report_error( execution_exception::user_error,
        -: 1134:                          "Invalid parameter detected by C runtime library" );
        -: 1135:}
        -: 1136:
        -: 1137://____________________________________________________________________________//
        -: 1138:
        -: 1139:} // namespace detail
        -: 1140:
        -: 1141:// ************************************************************************** //
        -: 1142:// **************        execution_monitor::catch_signals      ************** //
        -: 1143:// ************************************************************************** //
        -: 1144:
        -: 1145:int
        -: 1146:execution_monitor::catch_signals( boost::function<int ()> const& F )
        -: 1147:{
        -: 1148:    _invalid_parameter_handler old_iph = _invalid_parameter_handler();
        -: 1149:    BOOST_TEST_CRT_HOOK_TYPE old_crt_hook = 0;
        -: 1150:
        -: 1151:    if( p_catch_system_errors ) {
        -: 1152:        old_crt_hook = BOOST_TEST_CRT_SET_HOOK( &detail::assert_reporting_function );
        -: 1153:
        -: 1154:        old_iph = _set_invalid_parameter_handler(
        -: 1155:            reinterpret_cast<_invalid_parameter_handler>( &detail::invalid_param_handler ) );
        -: 1156:    } else if( !p_detect_fp_exceptions ) {
        -: 1157:#if BOOST_WORKAROUND( BOOST_MSVC, <= 1310)
        -: 1158:        _set_se_translator( &detail::seh_catch_preventer );
        -: 1159:#endif
        -: 1160:    }
        -: 1161:
        -: 1162:#if defined(BOOST_TEST_WIN32_WAITABLE_TIMERS)
        -: 1163:    HANDLE htimer = INVALID_HANDLE_VALUE;
        -: 1164:    BOOL bTimerSuccess = FALSE;
        -: 1165:
        -: 1166:    if( p_timeout ) {
        -: 1167:        htimer = ::CreateWaitableTimer(
        -: 1168:            NULL,
        -: 1169:            TRUE,
        -: 1170:            NULL); // naming the timer might create collisions
        -: 1171:
        -: 1172:        if( htimer != INVALID_HANDLE_VALUE ) {
        -: 1173:            LARGE_INTEGER liDueTime;
        -: 1174:            liDueTime.QuadPart = - static_cast<signed long int>(p_timeout) * 10; // resolution of 100 ns
        -: 1175:
        -: 1176:            bTimerSuccess = ::SetWaitableTimer(
        -: 1177:                htimer,
        -: 1178:                &liDueTime,
        -: 1179:                0,
        -: 1180:                0,
        -: 1181:                0,
        -: 1182:                FALSE);           // Do not restore a suspended system
        -: 1183:        }
        -: 1184:    }
        -: 1185:#endif 
        -: 1186:
        -: 1187:    detail::system_signal_exception SSE( this );
        -: 1188:
        -: 1189:    int ret_val = 0;
        -: 1190:    // clang windows workaround: this not available in __finally scope
        -: 1191:    bool l_catch_system_errors = p_catch_system_errors;
        -: 1192:
        -: 1193:    __try {
        -: 1194:        __try {
        -: 1195:            ret_val = detail::do_invoke( m_custom_translators, F );
        -: 1196:        }
        -: 1197:        __except( SSE( GetExceptionCode(), GetExceptionInformation() ) ) {
        -: 1198:            throw SSE;
        -: 1199:        }
        -: 1200:
        -: 1201:        // we check for time outs: we do not have any signaling facility on Win32
        -: 1202:        // however, we signal a timeout as a hard error as for the other operating systems
        -: 1203:        // and throw the signal error handler
        -: 1204:        if( bTimerSuccess && htimer != INVALID_HANDLE_VALUE) {
        -: 1205:            if (::WaitForSingleObject(htimer, 0) == WAIT_OBJECT_0) {
        -: 1206:                SSE.set_timed_out();
        -: 1207:                throw SSE;
        -: 1208:            }
        -: 1209:        }
        -: 1210:
        -: 1211:    }
        -: 1212:    __finally {
        -: 1213:
        -: 1214:#if defined(BOOST_TEST_WIN32_WAITABLE_TIMERS)
        -: 1215:        if( htimer != INVALID_HANDLE_VALUE ) {
        -: 1216:            ::CloseHandle(htimer);
        -: 1217:        }
        -: 1218:#endif
        -: 1219:
        -: 1220:        if( l_catch_system_errors ) {
        -: 1221:            BOOST_TEST_CRT_SET_HOOK( old_crt_hook );
        -: 1222:
        -: 1223:           _set_invalid_parameter_handler( old_iph );
        -: 1224:        }
        -: 1225:    }
        -: 1226:
        -: 1227:    return ret_val;
        -: 1228:}
        -: 1229:
        -: 1230://____________________________________________________________________________//
        -: 1231:
        -: 1232:#else  // default signal handler
        -: 1233:
        -: 1234:namespace detail {
        -: 1235:
        -: 1236:class system_signal_exception {
        -: 1237:public:
    #####: 1238:    void   report() const {}
        -: 1239:};
        -: 1240:
        -: 1241:} // namespace detail
        -: 1242:
        -: 1243:int
       14: 1244:execution_monitor::catch_signals( boost::function<int ()> const& F )
        -: 1245:{
       14: 1246:    return detail::do_invoke( m_custom_translators , F );
       14: 1246-block  0
        -: 1247:}
        -: 1248:
        -: 1249://____________________________________________________________________________//
        -: 1250:
        -: 1251:#endif  // choose signal handler
        -: 1252:
        -: 1253:// ************************************************************************** //
        -: 1254:// **************              execution_monitor               ************** //
        -: 1255:// ************************************************************************** //
        -: 1256:
        2: 1257:execution_monitor::execution_monitor()
        -: 1258:: p_catch_system_errors( true )
        -: 1259:, p_auto_start_dbg( false )
        -: 1260:, p_timeout( 0 )
        -: 1261:, p_use_alt_stack( true )
        2: 1262:, p_detect_fp_exceptions( fpe::BOOST_FPE_OFF )
        2: 1262-block  0
        2: 1263:{}
        -: 1264:
        -: 1265://____________________________________________________________________________//
        -: 1266:
        -: 1267:int
       14: 1268:execution_monitor::execute( boost::function<int ()> const& F )
        -: 1269:{
       14: 1270:    if( debug::under_debugger() )
       14: 1270-block  0
    #####: 1271:        p_catch_system_errors.value = false;
    %%%%%: 1271-block  0
        -: 1272:
        -: 1273:    BOOST_TEST_I_TRY {
       28: 1274:        detail::fpe_except_guard G( p_detect_fp_exceptions );
       14: 1274-block  0
       14: 1274-block  1
    $$$$$: 1274-block  2
        -: 1275:        boost::ignore_unused( G );
        -: 1276:
       14: 1277:        return catch_signals( F );
       14: 1277-block  0
       14: 1277-block  1
        -: 1278:    }
        -: 1279:
        -: 1280:#ifndef BOOST_NO_EXCEPTIONS
        -: 1281:
        -: 1282:    //  Catch-clause reference arguments are a bit different from function
        -: 1283:    //  arguments (ISO 15.3 paragraphs 18 & 19).  Apparently const isn't
        -: 1284:    //  required.  Programmers ask for const anyhow, so we supply it.  That's
        -: 1285:    //  easier than answering questions about non-const usage.
        -: 1286:
    =====: 1287:    catch( char const* ex )
    $$$$$: 1287-block  0
    $$$$$: 1287-block  1
    $$$$$: 1287-block  2
    =====: 1288:      { detail::report_error( execution_exception::cpp_exception_error,
        -: 1289:                              "C string: %s", ex ); }
    =====: 1290:    catch( std::string const& ex )
    $$$$$: 1290-block  0
    $$$$$: 1290-block  1
    $$$$$: 1290-block  2
    =====: 1291:      { detail::report_error( execution_exception::cpp_exception_error,
        -: 1292:                              "std::string: %s", ex.c_str() ); }
        -: 1293:
        -: 1294:    // boost::exception (before std::exception, with extended diagnostic)
    =====: 1295:    catch( boost::exception const& ex )
    $$$$$: 1295-block  0
    $$$$$: 1295-block  1
    =====: 1296:      { detail::report_error( execution_exception::cpp_exception_error,
    $$$$$: 1296-block  0
        -: 1297:                              &ex,
        -: 1298:#if defined(BOOST_NO_TYPEID) || defined(BOOST_NO_RTTI)
        -: 1299:                              "unknown boost::exception" ); }
        -: 1300:#else
    =====: 1301:                              boost::diagnostic_information(ex).c_str() ); }
    $$$$$: 1301-block  0
    $$$$$: 1301-block  1
    $$$$$: 1301-block  2
        -: 1302:#endif
        -: 1303:
        -: 1304:    //  std:: exceptions
        -: 1305:#if defined(BOOST_NO_TYPEID) || defined(BOOST_NO_RTTI)
        -: 1306:#define CATCH_AND_REPORT_STD_EXCEPTION( ex_name )                           \
        -: 1307:    catch( ex_name const& ex )                                              \
        -: 1308:       { detail::report_error( execution_exception::cpp_exception_error,    \
        -: 1309:                          current_exception_cast<boost::exception const>(), \
        -: 1310:                          #ex_name ": %s", ex.what() ); }                   \
        -: 1311:/**/
        -: 1312:#else
        -: 1313:#define CATCH_AND_REPORT_STD_EXCEPTION( ex_name )                           \
        -: 1314:    catch( ex_name const& ex )                                              \
        -: 1315:        { detail::report_error( execution_exception::cpp_exception_error,   \
        -: 1316:                          current_exception_cast<boost::exception const>(), \
        -: 1317:                          "%s: %s", detail::typeid_name(ex).c_str(), ex.what() ); } \
        -: 1318:/**/
        -: 1319:#endif
        -: 1320:
    =====: 1321:    CATCH_AND_REPORT_STD_EXCEPTION( std::bad_alloc )
    $$$$$: 1321-block  0
    $$$$$: 1321-block  1
    $$$$$: 1321-block  2
    $$$$$: 1321-block  3
    $$$$$: 1321-block  4
    $$$$$: 1321-block  5
    $$$$$: 1321-block  6
    =====: 1322:    CATCH_AND_REPORT_STD_EXCEPTION( std::bad_cast )
    $$$$$: 1322-block  0
    $$$$$: 1322-block  1
    $$$$$: 1322-block  2
    $$$$$: 1322-block  3
    $$$$$: 1322-block  4
    $$$$$: 1322-block  5
    $$$$$: 1322-block  6
    =====: 1323:    CATCH_AND_REPORT_STD_EXCEPTION( std::bad_typeid )
    $$$$$: 1323-block  0
    $$$$$: 1323-block  1
    $$$$$: 1323-block  2
    $$$$$: 1323-block  3
    $$$$$: 1323-block  4
    $$$$$: 1323-block  5
    $$$$$: 1323-block  6
    =====: 1324:    CATCH_AND_REPORT_STD_EXCEPTION( std::bad_exception )
    $$$$$: 1324-block  0
    $$$$$: 1324-block  1
    $$$$$: 1324-block  2
    $$$$$: 1324-block  3
    $$$$$: 1324-block  4
    $$$$$: 1324-block  5
    $$$$$: 1324-block  6
    =====: 1325:    CATCH_AND_REPORT_STD_EXCEPTION( std::domain_error )
    $$$$$: 1325-block  0
    $$$$$: 1325-block  1
    $$$$$: 1325-block  2
    $$$$$: 1325-block  3
    $$$$$: 1325-block  4
    $$$$$: 1325-block  5
    $$$$$: 1325-block  6
    =====: 1326:    CATCH_AND_REPORT_STD_EXCEPTION( std::invalid_argument )
    $$$$$: 1326-block  0
    $$$$$: 1326-block  1
    $$$$$: 1326-block  2
    $$$$$: 1326-block  3
    $$$$$: 1326-block  4
    $$$$$: 1326-block  5
    $$$$$: 1326-block  6
    =====: 1327:    CATCH_AND_REPORT_STD_EXCEPTION( std::length_error )
    $$$$$: 1327-block  0
    $$$$$: 1327-block  1
    $$$$$: 1327-block  2
    $$$$$: 1327-block  3
    $$$$$: 1327-block  4
    $$$$$: 1327-block  5
    $$$$$: 1327-block  6
    =====: 1328:    CATCH_AND_REPORT_STD_EXCEPTION( std::out_of_range )
    $$$$$: 1328-block  0
    $$$$$: 1328-block  1
    $$$$$: 1328-block  2
    $$$$$: 1328-block  3
    $$$$$: 1328-block  4
    $$$$$: 1328-block  5
    $$$$$: 1328-block  6
    =====: 1329:    CATCH_AND_REPORT_STD_EXCEPTION( std::range_error )
    $$$$$: 1329-block  0
    $$$$$: 1329-block  1
    $$$$$: 1329-block  2
    $$$$$: 1329-block  3
    $$$$$: 1329-block  4
    $$$$$: 1329-block  5
    $$$$$: 1329-block  6
    =====: 1330:    CATCH_AND_REPORT_STD_EXCEPTION( std::overflow_error )
    $$$$$: 1330-block  0
    $$$$$: 1330-block  1
    $$$$$: 1330-block  2
    $$$$$: 1330-block  3
    $$$$$: 1330-block  4
    $$$$$: 1330-block  5
    $$$$$: 1330-block  6
    =====: 1331:    CATCH_AND_REPORT_STD_EXCEPTION( std::underflow_error )
    $$$$$: 1331-block  0
    $$$$$: 1331-block  1
    $$$$$: 1331-block  2
    $$$$$: 1331-block  3
    $$$$$: 1331-block  4
    $$$$$: 1331-block  5
    $$$$$: 1331-block  6
    =====: 1332:    CATCH_AND_REPORT_STD_EXCEPTION( std::logic_error )
    $$$$$: 1332-block  0
    $$$$$: 1332-block  1
    $$$$$: 1332-block  2
    $$$$$: 1332-block  3
    $$$$$: 1332-block  4
    $$$$$: 1332-block  5
    $$$$$: 1332-block  6
    =====: 1333:    CATCH_AND_REPORT_STD_EXCEPTION( std::runtime_error )
    $$$$$: 1333-block  0
    $$$$$: 1333-block  1
    $$$$$: 1333-block  2
    $$$$$: 1333-block  3
    $$$$$: 1333-block  4
    $$$$$: 1333-block  5
    $$$$$: 1333-block  6
    =====: 1334:    CATCH_AND_REPORT_STD_EXCEPTION( std::exception )
    $$$$$: 1334-block  0
    $$$$$: 1334-block  1
    $$$$$: 1334-block  2
    $$$$$: 1334-block  3
    $$$$$: 1334-block  4
    $$$$$: 1334-block  5
    $$$$$: 1334-block  6
        -: 1335:#undef CATCH_AND_REPORT_STD_EXCEPTION
        -: 1336:
        -: 1337:    // system errors
    =====: 1338:    catch( system_error const& ex )
    $$$$$: 1338-block  0
    $$$$$: 1338-block  1
    $$$$$: 1338-block  2
    =====: 1339:      { detail::report_error( execution_exception::cpp_exception_error,
    =====: 1340:                              "system_error produced by: %s: %s", ex.p_failed_exp, std::strerror( ex.p_errno ) ); }
    $$$$$: 1340-block  0
    =====: 1341:    catch( detail::system_signal_exception const& ex )
    $$$$$: 1341-block  0
    =====: 1342:      { ex.report(); }
        -: 1343:
        -: 1344:    // not an error
    =====: 1345:    catch( execution_aborted const& )
    $$$$$: 1345-block  0
    =====: 1346:      { return 0; }
        -: 1347:
        -: 1348:    // just forward
    =====: 1349:    catch( execution_exception const& )
    $$$$$: 1349-block  0
    $$$$$: 1349-block  1
    =====: 1350:      { throw; }
        -: 1351:
        -: 1352:    // unknown error
    =====: 1353:    catch( ... )
    $$$$$: 1353-block  0
    $$$$$: 1353-block  1
    $$$$$: 1353-block  2
    =====: 1354:      { detail::report_error( execution_exception::cpp_exception_error, "unknown type" ); }
        -: 1355:
        -: 1356:#endif // !BOOST_NO_EXCEPTIONS
        -: 1357:
    =====: 1358:    return 0;  // never reached; supplied to quiet compiler warnings
    $$$$$: 1358-block  0
        -: 1359:} // execute
        -: 1360:
        -: 1361://____________________________________________________________________________//
        -: 1362:
        -: 1363:namespace detail {
        -: 1364:
        -: 1365:struct forward {
       14: 1366:    explicit    forward( boost::function<void ()> const& F ) : m_F( F ) {}
        -: 1367:
       14: 1368:    int         operator()() { m_F(); return 0; }
       14: 1368-block  0
        -: 1369:
        -: 1370:    boost::function<void ()> const& m_F;
        -: 1371:};
        -: 1372:
        -: 1373:} // namespace detail
        -: 1374:void
       14: 1375:execution_monitor::vexecute( boost::function<void ()> const& F )
        -: 1376:{
       14: 1377:    execute( detail::forward( F ) );
       14: 1377-block  0
       14: 1377-block  1
       14: 1377-block  2
    $$$$$: 1377-block  3
    $$$$$: 1377-block  4
       14: 1378:}
        -: 1379:
        -: 1380:// ************************************************************************** //
        -: 1381:// **************                  system_error                ************** //
        -: 1382:// ************************************************************************** //
        -: 1383:
    #####: 1384:system_error::system_error( char const* exp )
        -: 1385:#ifdef UNDER_CE
        -: 1386:: p_errno( GetLastError() )
        -: 1387:#else
    #####: 1388:: p_errno( errno )
    %%%%%: 1388-block  0
        -: 1389:#endif
    #####: 1390:, p_failed_exp( exp )
    #####: 1391:{}
        -: 1392:
        -: 1393://____________________________________________________________________________//
        -: 1394:
        -: 1395:// ************************************************************************** //
        -: 1396:// **************              execution_exception             ************** //
        -: 1397:// ************************************************************************** //
        -: 1398:
    #####: 1399:execution_exception::execution_exception( error_code ec_, const_string what_msg_, location const& location_ )
        -: 1400:: m_error_code( ec_ )
    #####: 1401:, m_what( what_msg_.empty() ? BOOST_TEST_L( "uncaught exception, system error or abort requested" ) : what_msg_ )
    #####: 1402:, m_location( location_ )
    %%%%%: 1402-block  0
    %%%%%: 1402-block  1
    %%%%%: 1402-block  2
    %%%%%: 1402-block  3
    #####: 1403:{}
        -: 1404:
        -: 1405://____________________________________________________________________________//
        -: 1406:
    #####: 1407:execution_exception::location::location( char const* file_name, size_t line_num, char const* func )
        -: 1408:: m_file_name( file_name ? file_name : "unknown location" )
        -: 1409:, m_line_num( line_num )
    #####: 1410:, m_function( func )
    %%%%%: 1410-block  0
    %%%%%: 1410-block  1
    %%%%%: 1410-block  2
    %%%%%: 1410-block  3
    #####: 1411:{}
        -: 1412:
    #####: 1413:execution_exception::location::location(const_string file_name, size_t line_num, char const* func )
        -: 1414:: m_file_name( file_name )
        -: 1415:, m_line_num( line_num )
    #####: 1416:, m_function( func )
    %%%%%: 1416-block  0
    #####: 1417:{}
        -: 1418:
        -: 1419://____________________________________________________________________________//
        -: 1420:
        -: 1421:// ************************************************************************** //
        -: 1422:// **************Floating point exception management interface ************** //
        -: 1423:// ************************************************************************** //
        -: 1424:
        -: 1425:namespace fpe {
        -: 1426:
        -: 1427:unsigned
    #####: 1428:enable( unsigned mask )
        -: 1429:{
        -: 1430:    boost::ignore_unused(mask);
        -: 1431:#if defined(BOOST_TEST_FPE_SUPPORT_WITH_SEH__)
        -: 1432:    _clearfp();
        -: 1433:
        -: 1434:#if BOOST_WORKAROUND( BOOST_MSVC, <= 1310)
        -: 1435:    unsigned old_cw = ::_controlfp( 0, 0 );
        -: 1436:    ::_controlfp( old_cw & ~mask, BOOST_FPE_ALL );
        -: 1437:#else
        -: 1438:    unsigned old_cw;
        -: 1439:    if( ::_controlfp_s( &old_cw, 0, 0 ) != 0 )
        -: 1440:        return BOOST_FPE_INV;
        -: 1441:
        -: 1442:    // Set the control word
        -: 1443:    if( ::_controlfp_s( 0, old_cw & ~mask, BOOST_FPE_ALL ) != 0 )
        -: 1444:        return BOOST_FPE_INV;
        -: 1445:#endif
        -: 1446:    return ~old_cw & BOOST_FPE_ALL;
        -: 1447:
        -: 1448:#elif defined(BOOST_TEST_FPE_SUPPORT_WITH_GLIBC_EXTENSIONS__)
        -: 1449:    // same macro definition as in execution_monitor.hpp
        -: 1450:    if (BOOST_FPE_ALL == BOOST_FPE_OFF)
        -: 1451:        /* Not Implemented */
        -: 1452:        return BOOST_FPE_OFF;
        -: 1453:    feclearexcept(BOOST_FPE_ALL);
        -: 1454:    int res = feenableexcept( mask );
        -: 1455:    return res == -1 ? (unsigned)BOOST_FPE_INV : (unsigned)res;
        -: 1456:#else
        -: 1457:    /* Not Implemented  */
    #####: 1458:    return BOOST_FPE_OFF;
    %%%%%: 1458-block  0
        -: 1459:#endif
        -: 1460:}
        -: 1461:
        -: 1462://____________________________________________________________________________//
        -: 1463:
        -: 1464:unsigned
       14: 1465:disable( unsigned mask )
        -: 1466:{
        -: 1467:    boost::ignore_unused(mask);
        -: 1468:
        -: 1469:#if defined(BOOST_TEST_FPE_SUPPORT_WITH_SEH__)
        -: 1470:    _clearfp();
        -: 1471:#if BOOST_WORKAROUND( BOOST_MSVC, <= 1310)
        -: 1472:    unsigned old_cw = ::_controlfp( 0, 0 );
        -: 1473:    ::_controlfp( old_cw | mask, BOOST_FPE_ALL );
        -: 1474:#else
        -: 1475:    unsigned old_cw;
        -: 1476:    if( ::_controlfp_s( &old_cw, 0, 0 ) != 0 )
        -: 1477:        return BOOST_FPE_INV;
        -: 1478:
        -: 1479:    // Set the control word
        -: 1480:    if( ::_controlfp_s( 0, old_cw | mask, BOOST_FPE_ALL ) != 0 )
        -: 1481:        return BOOST_FPE_INV;
        -: 1482:#endif
        -: 1483:    return ~old_cw & BOOST_FPE_ALL;
        -: 1484:
        -: 1485:#elif defined(BOOST_TEST_FPE_SUPPORT_WITH_GLIBC_EXTENSIONS__)
        -: 1486:    if (BOOST_FPE_ALL == BOOST_FPE_OFF)
        -: 1487:        /* Not Implemented */
        -: 1488:        return BOOST_FPE_INV;
        -: 1489:    feclearexcept(BOOST_FPE_ALL);
        -: 1490:    int res = fedisableexcept( mask );
        -: 1491:    return res == -1 ? (unsigned)BOOST_FPE_INV : (unsigned)res;
        -: 1492:#else
        -: 1493:    /* Not Implemented */
       14: 1494:    return BOOST_FPE_INV;
       14: 1494-block  0
        -: 1495:#endif
        -: 1496:}
        -: 1497:
        -: 1498://____________________________________________________________________________//
        -: 1499:
        -: 1500:} // namespace fpe
        -: 1501:
        -: 1502:} // namespace boost
        -: 1503:
        -: 1504:#include <boost/test/detail/enable_warnings.hpp>
        -: 1505:
        -: 1506:#endif // BOOST_TEST_EXECUTION_MONITOR_IPP_012205GER
